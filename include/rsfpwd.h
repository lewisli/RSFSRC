/* This file is automatically generated. DO NOT EDIT! */

#ifndef _allp2_h
#define _allp2_h


typedef struct Allpass2 *allpas2;
/* abstract data type */


allpas2 allpass2_init(int nw         /* filter order */, 
		       int nj         /* filter step */, 
		       int nx, int ny /* data size */, 
		       float **pp     /* dip [ny][nx] */);
/*< Initialize >*/


void allpass2_close(allpas2 ap);
/*< free allocated storage >*/


void allpass22_init (allpas2 ap1);
/*< Initialize linear operator >*/


void allpass21_lop (bool adj, bool add, int n1, int n2, float* xx, float* yy);
/*< PWD as linear operator >*/


void allpass21 (bool der          /* derivative flag */, 
		const allpas2 ap /* PWD object */, 
		float** xx        /* input */, 
		float** yy        /* output */);
/*< plane-wave destruction >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _allp3_h
#define _allp3_h


typedef struct Allpass *allpass;
/* abstract data type */


allpass allpass_init(int nw                 /* filter size */, 
		     int nj                 /* filter step */, 
		     int nx, int ny, int nz /* data size */, 
		     float *pp              /* dip [nz*ny*nx] */);
/*< Initialize >*/


void allpass_close(allpass ap);
/*< free allocated storage >*/


void allpass1 (bool left        /* left or right prediction */,
	       bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< in-line plane-wave destruction >*/


void allpass2 (bool left        /* left or right prediction */,
	       bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< cross-line plane-wave destruction >*/


void allpass3_init (allpass ap, allpass aq);
/*< Initialize linear operator >*/


void allpass3_lop (bool adj, bool add, int n1, int n2, float* xx, float* yy);
/*< PWD as linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _apfilt_h
#define _apfilt_h


void apfilt_init(int nw /* filter order */);
/*< initialize >*/


void apfilt_close(void);
/*< free allocated storage >*/


void passfilter (float p  /* slope */, 
		 float* a /* output filter [n+1] */);
/*< find filter coefficients >*/


void aderfilter (float p  /* slope */, 
		 float* a /* output filter [n+1] */);
/*< find coefficients for filter derivative >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _copyk_h
#define _copyk_h


void copyk_init(int nk1 /* number of components */,
		int n1  /* size of one component */);
/*< initialize >*/


void copyk_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _dijkstra_h
#define _dijkstra_h


#include <rsf.h>


void dijkstra_init(int m1, int m2, 
		   float **udcost  /* up-down cost */, 
		   float ** lrcost /* left-right cost */);
/*< initialize with model size >*/


void dijkstra_close(void);
/*< free allocated storage >*/


void dijkstra_source(int s1, int s2);
/*< initialize source >*/


bool dijskstra_step(int *i1, int *i2, int *ud, int *lr);
/*< one step of the algorithm, true on success >*/


void dijkstra_start(int s1, int s2);
/*< intialize path >*/


bool dijkstra_next(int *ud, int *lr);
/*< find the next shift (up-down, left-right), return true on success >*/


void dijkstra_cost(sf_file out);
/*< write cost function >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _dip3_h
#define _dip3_h


void dip3_init(int m1, int m2, int m3 /* dimensions */, 
	       int* rect              /* smoothing radius [3] */, 
	       int niter              /* number of iterations */,
	       float eps1             /* regularization */,      
	       bool verb              /* verbosity flag */);
/*< initialize >*/


void dip3_close(void);
/*< free allocated storage >*/


void dip3(bool left               /* left or right prediction */,
	  int dip                 /* 1 - inline, 2 - crossline */, 
	  int niter               /* number of nonlinear iterations */, 
	  int nw                  /* filter size */, 
	  int nj                  /* filter stretch for aliasing */, 
	  bool verb               /* verbosity */, 
	  float *u                /* input data */, 
	  float* p                /* output dip */, 
	  bool* mask              /* input mask for known data */,
	  float pmin, float pmax  /* minimum and maximum dip */);
/*< estimate local dip >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _diplet_h
#define _diplet_h


void diplet_init(int n1      /* trace length */, 
		 int n2      /* number of traces */,
		 int np1     /* number of slopes */,
		 float ***p1 /* slopes */,
		 float ***m1 /* data mask */,
		 bool inv    /* inversion flag */, 
		 float eps   /* regularization parameter */,
		 int order   /* accuracy order */,
		 char type   /* transform type */);
/*< allocate space >*/


void diplet_close(void);
/*< deallocate space >*/


void diplet_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _div2_h
#define _div2_h


void div2_init(int n1, int n2     /* data dimensions */, 
	       float f1, float f2 /* smoothing */, 
	       int niter1         /* number of iterations */, 
	       bool gauss1        /* if exact gaussian */,
	       bool verb          /* verbosity flag */);
/*< initialize >*/


void div2_close (void);
/*< free allocated storage >*/


void div2 (float* num, float* den,  float* rat);
/*< smooth division: rat=num/den >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _explanesignoi_h
#define _explanesignoi_h


#include <rsf.h>


void explanesignoi_init (int m1,int m2 /* data size */, 
			 float eps1    /* signal/noise scaling */, 
			 float **aa    /* frequency filter [4][m1*m2] */, 
			 int nw        /* dip filter order */, 
			 int nj1       /* dip filter step for noise */, 
			 int nj2       /* dip filter step for signal */, 
			 float **nn    /* noise dip [m1*m2] */, 
			 float **ss    /* signal dip [m1*m2] */);
/*< initialize >*/


void explanesignoi_close(void);
/*< free allocated storage >*/


void explanesignoi_lop (bool adj, bool add, int ns, int nd, 
			float *ss, float *dat);
/*< linear operator for inversion >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _expont_h
#define _expont_h


#include <rsf.h>


void expont_init(int n1_in,int n2_in /* data size */, 
		 float *a1           /* filter component [n1*n2] */, 
		 float *b1           /* filter component [n1*n2] */);
/*< initialize >*/


void expont_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _expsignoi2_h
#define _expsignoi2_h


#include <rsf.h>


void expsignoi2_init (int m1,int m2 /* data size */, 
		      float eps1    /* signal/noise scaling */, 
		      float **aa    /* frequency filter [4][m1*m2] */);
/*< initialize >*/


void expsignoi2_close(void);
/*< free allocated storage >*/


void expsignoi2_lop (bool adj, bool add, int ns, int nd, 
		     float *sig /* signal */, float *dat /* data */);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _fdip_h
#define _fdip_h


void fdip_init(int m1,int m2,int m3,int *rect, int niter, bool verb);
/*< initialize >*/


void fdip_close();
/*< release work space >*/


void fdip(float *in,float *out, 
	  bool **mask, /* input mask for known data */
	  int dim /* 0 - inline; 1 - xline; X - both*/);
/*< 3D dip estimation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _gauss2_h
#define _gauss2_h


void gauss2_init(int n1, int n2     /* data size */, 
		 float f1, float f2 /* smoothing radius */);
/*< initialize (call freqfilt2 afterwards) >*/


void gauss2_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mask6_h
#define _mask6_h


#include <rsf.h>


void mask32 (bool both              /* left and right predictions */,
	     int nw                 /* filter size */, 
	     int nj1, int nj2       /* dealiasing stretch */, 
	     int nx, int ny, int nz /* data size */, 
	     float *yy              /* data [nz*ny*nx] */, 
	     bool **m               /* dip mask [both? 4:2][nz*ny*nx] */);
/*< two-dip masks in 3-D >*/


void mask3 (int nw         /* filter size */, 
	    int nj         /* dealiasing stretch */, 
	    int nx, int ny /* data size */, 
	    float **yy     /* data */, 
	    bool **mm      /* mask */);
/*< one-dip mask in 2-D >*/


void mask6 (int nw           /* filter size */, 
	    int nj1, int nj2 /* dealiasing stretch */, 
	    int nx, int ny   /* data size */, 
	    float *yy       /* data [ny][nx] */, 
	    bool *mm        /* mask [ny][nx] */);
/*< two-dip mask in 2-D >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _planesignoi_h
#define _planesignoi_h


#include <rsf.h>


void planesignoi_init (int nw           /* filter size */, 
		       int nj1, int nj2 /* dealiasing stretch */, 
		       int nx, int ny   /* data size */, 
		       float **nn       /* noise slope */, 
		       float **ss       /* signal slope */, 
		       float eps1       /* regularization parameter */);
/*< initialize >*/


void planesignoi_lop (bool adj, bool add, int ns, int nd, float *s, float *d);
/*< linear operator >*/


void planesignoi_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predict_h
#define _predict_h


#include <rsf.h>


void predict_init (int nx, int ny /* data size */, 
		   float e        /* regularization parameter */,
		   int nw         /* accuracy order */,
		   int k          /* radius */,
		   bool two       /* if two predictions */);
/*< initialize >*/


void predict_close (void);
/*< free allocated storage >*/


void predict_step(bool adj            /* adjoint flag */,
		  bool forw           /* forward or backward */, 
		  float* trace        /* input/output trace */,
		  const float* pp    /* slope */);
/*< prediction step >*/


void predict1_step(bool forw      /* forward or backward */, 
		   float* trace1  /* input trace */,
		   const float* pp /* slope */,
		   float* trace /* output trace */);
/*< prediction step from one trace >*/


void predict2_step(bool forw1        /* forward or backward */, 
		   bool forw2,
		   float* trace1     /* input trace */,
		   float* trace2,
		   const float* pp1  /* slope */,
		   const float* pp2,
		   float *trace      /* output trace */);
/*< prediction step from two traces>*/


void predict_set(float **dip1 /* dip field [n2][n1] */);
/*< set the local slopes for applying the linear operator >*/


void predict_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void predicter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void subtracter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void subtract_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predict2_h
#define _predict2_h


void predict2_init(int m1, int m2           /* data dimensions */, 
		   float eps                /* regularization parameter */,
		   int order                /* accuracy order */,
		   float** pp, float **qq   /* slopes [m1][m2] */);
/*< initialize >*/


void predict2_close(void);
/*< free allocated storage >*/


void predict2_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predk_h
#define _predk_h


void predk_init(int nk          /* number of components */,
		int m1, int m2  /* data dimensions */, 
		float eps       /* regularization parameter */,
		int order       /* accuracy order */,
		float*** pk     /* slopes [nk][m1][m2] */);
/*< initialize >*/


void predk_close(void);
/*< free allocated storage >*/


void predk_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwd_h
#define _pwd_h


#include <rsf.h>


typedef struct Pwd *pwd; /* abstract data type */


pwd pwd_init(int n1 /* trace length */, 
	     int nw /* filter order */);
/*< initialize >*/


void pwd_close (pwd w);
/*< free allocated storage >*/


void pwd_define (bool adj        /* adjoint flag */, 
		 pwd w           /* pwd object */, 
		 const float* pp /* slope */, 
		 float* diag     /* defined diagonal */, 
		 float** offd    /* defined off-diagonal */);
/*< fill the matrix >*/


void pwd_set (bool adj   /* adjoint flag */,
	      pwd w      /* pwd object */, 
	      float* inp /* input */, 
	      float* out /* output */, 
	      float* tmp /* temporary storage */);
/*< matrix multiplication >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwdsl_h
#define _pwdsl_h


#include <rsf.h>


void pwdsl_init(int m1, int m2       /* data dimensions */,
		int order            /* accuracy order */,
		int rect1, int rect2 /* triangle radius */,
		float eps            /* regularization parameter */);
/*< initialize >*/


void pwdsl_set(float **dip /* dip field [n2][n1] */);
/*< set the local slopes for applying the linear operator >*/


void pwdsl_close(void);
/*< free allocated storage >*/


void pwdsl_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwsmooth_h
#define _pwsmooth_h


void pwsmooth_init(int ns      /* spray radius */,
		   int m1      /* trace length */,
		   int m2      /* number of traces */,
		   int order   /* PWD order */,
		   float eps   /* regularization */,
		   float **dip /* local slope */);
/*< initialize >*/


void pwsmooth_close(void);
/*< free allocated storage >*/


void pwsmooth_lop(bool adj, bool add, 
		  int nin, int nout, float* trace, float *smooth);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwspray_h
#define _pwspray_h


int pwspray_init(int nr      /* spray radius */, 
		 int nt      /* trace length */, 
		 int n       /* number of traces */,
		 int order   /* PWD order */,
		 float eps   /* regularization */,
		 float **dip /* local slope */);
/*< initialize >*/


void pwspray_close(void);
/*< free allocated storage >*/


void pwspray_lop(bool adj, bool add, int n, int nu, float* u1, float *u);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _repeat2_h
#define _repeat2_h


#include <rsf.h>


void repeat2_init(int m1            /* trace length */, 
		  int m2            /* number of traces */, 
		  sf_operator oper1 /* operator */);
/*< initialize >*/


void repeat2_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< combined linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _seislet_h
#define _seislet_h


void seislet_init(int n1      /* trace length */, 
		  int n2      /* number of traces */, 
		  bool inv1   /* inversion flag */, 
		  bool unit1  /* weighting flag */,
		  float eps   /* regularization parameter */,
		  int order   /* accuracy order */,
		  char type   /* transform type */);
/*< allocate space >*/


void seislet_set(float **dip /* local slope */);
/*< set local slope >*/


void seislet_close(void);
/*< deallocate space >*/


void seislet_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/


void seislet_destruct(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/


void seislet_construct(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _seisletk_h
#define _seisletk_h


void seisletk_init(int nk      /* number of components */,
		   int n1      /* trace length */, 
		   int n2      /* number of traces */, 
		   bool inv    /* inversion flag */, 
		   float eps   /* regularization parameter */,
		   int order   /* accuracy order */,
		   char type   /* transform type */,
		   float*** pk /* slopes [nk][m1][m2] */);
/*< initialize >*/


void seisletk_close(void);
/*< free allocated storage >*/


void seisletk_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _smoothshape_h
#define _smoothshape_h


void smoothshape_init(int n1, int n2        /* data size */,
		      int order             /* accuracy order */,
		      int rect1, int rect2  /* smoothing radius */,
		      float lam             /* operator scaling */,
		      float **dip           /* dip field */);
/*< initialize >*/


void smoothshape_close(void);
/*< free allocated storage >*/


void smoothshape(int niter     /* number of iterations */, 
		 float* weight /* data weighting */, 
		 float* data   /* input data */, 
		 float* der    /* output derivative */);
/*< find the derivative >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _trisl_h
#define _trisl_h


#include <rsf.h>


void trisl_init(int m1, int m2       /* data dimensions */, 
		int rect1, int rect2 /* triangle radius */);
/*< initialize >*/


void trisl_set(float** p1 /* slope [m2][m1] */);
/*< set slopes >*/


void trisl_close(void);
/*< free allocated storage >*/


void trisl_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _twodip2_h
#define _twodip2_h


#include <rsf.h>


void twodip2_init(int nx, int ny     /* data size */, 
		  float fx, float fy /* smoothing radius */, 
		  bool sign1         /* if keep slope signs */,
		  bool gauss         /* Gaussian versus triangle smoothing */,
		  bool verb          /* verbosity flag */,
		  bool both          /* both slopes or one */);
/*< initialize >*/


void twodip2_close(void);
/*< free allocated storage >*/


void twodip2(int niter        /* number of iterations */, 
	     int nw           /* filter order */, 
	     int nj1, int nj2 /* dealisianing stretch */, 
	     bool verb        /* verbosity flag */, 
	     float *u         /* input data */, 
	     float** pq       /* output slopes */, 
	     bool *mask       /* mask for missing data */);
/*< estimate slopes >*/


void otherdip2(int niter        /* number of iterations */, 
	       int nw           /* filter order */, 
	       int nj1, int nj2 /* dealising stretch */, 
	       bool verb        /* verbosity flag */, 
	       float *u         /* input data */, 
	       float** pq       /* output slope */, 
	       bool *mask       /* mask for missing data */);
/*< estimate the second slope only >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _twoplane2_h
#define _twoplane2_h


#include <rsf.h>


void twoplane2_init (int nw_in            /* filter size */, 
		     int nj1, int nj2     /* dealising stretch */, 
		     int nx_in, int ny_in /* data size */,
		     float **pp           /* first slope */, 
		     float **qq           /* second slope */);
/*< initialize >*/


void twoplane2_close(void);
/*< free allocated storage >*/


void twoplane2_lop (bool adj, bool add, int n1, int n2, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _update_h
#define _update_h


void update_init(int m1, int m2 /* dimensions */,
		 float *t       /* [m1,m2] traveltime */);
/*< initialize >*/


void update_close(void);
/*< free allocated storage >*/


unsigned char get_update(int i, bool *up1, bool *up2, int *j);
/*< next update step >*/

#endif
